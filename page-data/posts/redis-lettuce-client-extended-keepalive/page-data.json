{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/redis-lettuce-client-extended-keepalive/","result":{"data":{"post":{"html":"<h2 id=\"요약\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD\" aria-label=\"요약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h2>\n<p>redis는 client - server간 어플리케이션 단에서 별도로 heartbeat packet을 통해 커넥션 유효 여부를 판단하지 않는다 <br>\n커넥션이 유효하지 않은지를 판단하려면 lettuce의 keepalive 옵션을 켜야 하는데 lettuce keepalive 옵션은 os(container) 설정을 따라가는 문제가 있다 <br>\n이 문제점은 lettuce 6.1부터 도입된 lettuce extended keepalive 옵션을 통해 어플리케이션단에서 tcp keepalive 값을 커스터마이징하는 것을 통해 해결할 수 있다 <br>\n따라서 subscribe, blpop 0 명령 등 서버로부터 응답이 오기까지 오래 걸릴 수 있는 명령을 수행하는 커넥션이 유효한지 원하는 시간 내에 판단할 수 있다(<a href=\"https://github.com/lettuce-io/lettuce-core/issues/1437\">https://github.com/lettuce-io/lettuce-core/issues/1437</a>)</p>\n<h2 id=\"lettuce-sentinel\" style=\"position:relative;\"><a href=\"#lettuce-sentinel\" aria-label=\"lettuce sentinel permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>lettuce sentinel</h2>\n<p>lettuce 클라이언트는 sentinel를 통해 redis를 연결하면 sentinel로부터 마스터 / 레플리카 정보를 가져오고 이를 통해 마스터 혹은 레플리카 레디스와 통신한다 <br>\n그리고 sentinel에 psubscribe * 명령어를 통해 failover 등의 이벤트가 발생하면 이를 통해 관련된 레디스 정보를 갱신한다(관련된 내용은 6.1.8 릴리즈 기준 io.lettuce.core.masterreplica.SentinelTopologyRefresh 클래스에서 확인할 수 있다)</p>\n<p>하지만 이후 센티널에서 페일오버가 발생하였으나, lettuce 클라이언트가 이를 인지하지 못해 잘못된 레디스 정보를 가지고 레디스로 통신을 시도하는 이슈가 발생한 적이 있었다 <br>\n이에 대한 원인을 찾던 도중 모종의 이유로 커넥션이 끊길 수가 있고 lettuce 클라이언트가 이를 인지하기 위해서는 lettuce extended keepalive 옵션을 사용해야 된다는 것을 알았다 <br>\n그리고 redis 메인테이너는 관련해서 어플리케이션 단에서 heartbeat 패킷을 보내는 것은 하위호환성 이슈가 있어 redis 클라이언트 메인테이너가 pub / sub 명령은 기본적으로 레디스 클라이언트에서 tcp keepalive 설정을 할 수 있도록 해야 한다고 이야기하고 있다(<a href=\"https://github.com/redis/redis/issues/7855\">https://github.com/redis/redis/issues/7855</a>)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.06936416184971%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABxElEQVQoz11Si26cQAzk//+oH1FVqlpFiZK24RHesOyyLHvATcc+7iJlpcEsNvbY4yR9fcHz02/YOaAfDSbnT8xYQsS2H7hsOy60kTZeNmJXyHfL2HFycD7oPWnrCnmeoetH5EWJqm5QElXd6nvbDeiGEU3bY5CC1inMZBX9YOjr4GaPnUUTnKeqary/p0jTjIkLZFmu9ywvWLDQ96ZtWaBD3w/wfsFx7EyyY9s2XK9XRSKP4zhgzEQYLMsCay0mVnfzjJmVHdu3zmnMSJZi736xI/8LYf1MKFXc4jXAsh3PpBIQ1hXrGtXGeHmwuEOI7ITY+3m0PEwGxcetPWm/bm4zLKsKH2WJlnOSNqWo1y6cEpGzReD7N4vyLSKpqxJFnqqiMmRR7QZRmQzJLJCl2K/YjytCjBxJQPmPxcyG5PXlCb9+/uDKTKpuTSY1FRWMxur6GK7FqLAKues3+htuQcVujDMssH+2LCq+/fmLhk5RsTvVbKmsjkBWibZpGvXJCFR1ISDrRatro6KcKksCUVSUnWVW3rPtQIGCqu9P3O+CWWKWoLGPPTw4i07ZdLqkwlKsBK7rTW1V/Uy+frmLXwqL2v8BAK9LYOtUn9IAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"redis-maintainer-comment\"\n        title=\"redis-maintainer-comment\"\n        src=\"/static/baca679e9b5d1f506d67b6ea3162b8ff/1e043/redis-maintainer-comment.png\"\n        srcset=\"/static/baca679e9b5d1f506d67b6ea3162b8ff/991de/redis-maintainer-comment.png 173w,\n/static/baca679e9b5d1f506d67b6ea3162b8ff/e4d6b/redis-maintainer-comment.png 345w,\n/static/baca679e9b5d1f506d67b6ea3162b8ff/1e043/redis-maintainer-comment.png 690w,\n/static/baca679e9b5d1f506d67b6ea3162b8ff/ecf19/redis-maintainer-comment.png 948w\"\n        sizes=\"(max-width: 690px) 100vw, 690px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>lettuce는 기본적으로 keepalive 옵션을 키면 os의 keepalive을 따라가고 있었다. <br>\n이를 os 설정을 따라가는 것이 아닌 fine-grained한 설정이 가능하도록 6.1부터 extended keepalive 옵션을 추가해주었다 <br>\n이를 통해 커넥션이 유효하지 않은 경우 다시 커넥션을 맺는 등의 액션을 취할 수 있다(reconnect 옵션이 켜져있으면 connectionWatchDog에 의해 다시 연결된다) <br>\n따라서 위와 같이 sentinel를 통해 redis를 연결하거나, 혹은 pub / sub, 오래 대기하는 명령어를 사용하는 경우는 위 옵션을 적용하자</p>\n<h2 id=\"여담\" style=\"position:relative;\"><a href=\"#%EC%97%AC%EB%8B%B4\" aria-label=\"여담 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>여담</h2>\n<p>lettuce extended keepalive 옵션을 사용해도, 커넥션이 유효하지 않은 상태가 있을 수 있다. 이 때 페일오버가 발생하고 후에 커넥션이 복구되어도 페일오버 관련되어 레디스 정보를 갱신하지 않는다. <br>\n즉, 새로운 이벤트가 발생하기 전까지 센티널로부터 레디스 정보를 가져오지 않기에 관련되어 이슈를 제보한 상황이다(<a href=\"https://github.com/lettuce-io/lettuce-core/issues/2007\">관련 링크</a>) <br>\n이를 처리할 방법이 어려울 것 같다고 계속 open되어 있는 상황이다</p>","excerpt":"요약 redis는 client - server간 어플리케이션 단에서 별도로 heartbeat packet을 통해 커넥션 유효 여부를 판단하지 않는다  커넥션이 유효하지 않은지를 판단하려면 lettuce의 keepalive…","timeToRead":2,"fields":{"slug":"/posts/redis-lettuce-client-extended-keepalive/"},"frontmatter":{"tags":["lettuce","redis","extended keepalive"],"author":{"id":"cprayer","bio":"","twitter":"@fabien0102","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5d0fd80a1d7df4f6a3adf452cc763c07/b0b39/cprayer.jpg","srcSet":"/static/5d0fd80a1d7df4f6a3adf452cc763c07/b0b39/cprayer.jpg 1x,\n/static/5d0fd80a1d7df4f6a3adf452cc763c07/93542/cprayer.jpg 1.5x,\n/static/5d0fd80a1d7df4f6a3adf452cc763c07/aa4d2/cprayer.jpg 2x"}}]}},"title":"redis lettuce client extended keepalive 옵션","updatedDate":"Feb 22, 2022","image":null}},"recents":{"edges":[{"node":{"fields":{"slug":"/posts/k8s-and-etc-resolv-conf/"},"timeToRead":4,"frontmatter":{"title":"k8s와 /etc/resolv.conf","image":null,"author":{"id":"cprayer","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5d0fd80a1d7df4f6a3adf452cc763c07/6d45f/cprayer.jpg","srcSet":"/static/5d0fd80a1d7df4f6a3adf452cc763c07/6d45f/cprayer.jpg 1x,\n/static/5d0fd80a1d7df4f6a3adf452cc763c07/fe190/cprayer.jpg 1.5x,\n/static/5d0fd80a1d7df4f6a3adf452cc763c07/3e51d/cprayer.jpg 2x"}}]}}}}},{"node":{"fields":{"slug":"/posts/redis-manually-force-a-failover/"},"timeToRead":1,"frontmatter":{"title":"강제로 레플리카 레디스를 마스터로 승격시키기","image":null,"author":{"id":"cprayer","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5d0fd80a1d7df4f6a3adf452cc763c07/6d45f/cprayer.jpg","srcSet":"/static/5d0fd80a1d7df4f6a3adf452cc763c07/6d45f/cprayer.jpg 1x,\n/static/5d0fd80a1d7df4f6a3adf452cc763c07/fe190/cprayer.jpg 1.5x,\n/static/5d0fd80a1d7df4f6a3adf452cc763c07/3e51d/cprayer.jpg 2x"}}]}}}}},{"node":{"fields":{"slug":"/posts/hbase-client-dns-excessive-query-issue/"},"timeToRead":2,"frontmatter":{"title":"hbase sharded client 1.2 dns 과다 질의 이슈","image":null,"author":{"id":"cprayer","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5d0fd80a1d7df4f6a3adf452cc763c07/6d45f/cprayer.jpg","srcSet":"/static/5d0fd80a1d7df4f6a3adf452cc763c07/6d45f/cprayer.jpg 1x,\n/static/5d0fd80a1d7df4f6a3adf452cc763c07/fe190/cprayer.jpg 1.5x,\n/static/5d0fd80a1d7df4f6a3adf452cc763c07/3e51d/cprayer.jpg 2x"}}]}}}}},{"node":{"fields":{"slug":"/posts/dbcp2-communication-exception-issue/"},"timeToRead":4,"frontmatter":{"title":"dbcp2 pool idle configuration이 있는데도 communicationsException 발생 원인 파악","image":null,"author":{"id":"cprayer","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5d0fd80a1d7df4f6a3adf452cc763c07/6d45f/cprayer.jpg","srcSet":"/static/5d0fd80a1d7df4f6a3adf452cc763c07/6d45f/cprayer.jpg 1x,\n/static/5d0fd80a1d7df4f6a3adf452cc763c07/fe190/cprayer.jpg 1.5x,\n/static/5d0fd80a1d7df4f6a3adf452cc763c07/3e51d/cprayer.jpg 2x"}}]}}}}}]}},"pageContext":{"slug":"/posts/redis-lettuce-client-extended-keepalive/"}},"staticQueryHashes":[]}